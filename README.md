# St-Petersburg-Paradox-usingMonteCarloSimulation-
The St. Petersburg paradox by Daniel Bernoulli is a gambling game. It works as follows: A fair coin is tossed and the player invests an amount (Say, £1) . If the coin shows up ‘Tail’, the user will continue to play the game until the coin shows ‘Heads’. The game will pay £2 for every toss. To explain, if the coin turns up head on the 3rd toss, the game ends and the player will get £8 (£2 for each toss). The player will win with the gain of £7.  Suppose, if the user bets a larger amount than the payoff, it is obvious that the player will lose the game. The paradox arises here, when the expected value is infinite on applying probabilities on the result of each payoff. 2 (  1/2 ) + 2*2 (  1/(2*2) ) + 2*2*2 (  1/(2*2*2) ) + . . . +2n (  1/(2n ) )  + . . . = 1 + 1 + 1 + . . . + 1 + . . . = ∞ Though the expected payoff looks infinite, there are 50% of chances to win only £2 as the payoff. Nobody will be willing to pay larger amount when there is 50% of chance to lose the game. To match the theoretical results with real time game looks difficult. By using Monte Carlo Simulation, the uncertainty could be reduced as the mean large number of samples is taken to forecast the winning amount. To experiment the given problem for larger number of samples, the R code is written in Brute-Force approach and attached to the assignment. This program will have to know the Pay to Play and the Number of Games, which are assigned to the respective vectors. The function ‘sample ()’ in  R will generate a random sample which is equivalent to coin toss. The coin toss is set to ‘T’ initially. A while loop will have a ‘temp’ variable to increment 1 on every toss until ‘H’is encountered. If the coin turns up ‘Heads’, the while loop breaks and the winning amount will be stored in ‘CoinTossSum’ vector. This logic is written inside nested ‘for’ loops to run it for different Pay and for various number of games for 50000 simulations. The outer loop ‘k’ executes the length of Pay to play vector times. Every time the outer loop executes, the inner loop executes ‘j’ (Average number of games vector times) and i ( Simulation) times. As a result, the program executes a total of i *j * k times. Thus, the complexity is O(i*j*k). The total complexity for the loops is O(n3). The average of all the simulation is calculated and subtracted to the amount payed to play. The final amount is stored in a 2D matrix where the rows contains ‘Pay to play' and the columns are ‘Average number of games’ . The output is copied to an Excel file and attached.  On analysing the output for the amount from £1 to £50 across 1 to 50 games, the output is random. As proved theoretically, the pay off is infinite. The reasonable pay depends on the player, for someone £20 pounds may also be a higher amount in that case it is based on the affordability of the player. 
